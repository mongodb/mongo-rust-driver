use super::Client;
use crate::{
    cmap::Connection,
    error::Result,
    operation::Operation,
    sdam::{update_topology, ServerDescription},
};

impl Client {
    /// Executes an operation and returns the connection used to do so along with the result of the
    /// operation. This will be used primarily for the opening of exhaust cursors.
    #[allow(dead_code)]
    pub(crate) fn execute_exhaust_operation<T: Operation>(
        &self,
        op: &T,
    ) -> Result<(T::O, Connection)> {
        let mut conn = self
            .select_server(op.selection_criteria())?
            .checkout_connection()?;
        self.execute_operation_on_connection(op, &mut conn)?
            .map(|r| (r, conn))
    }

    /// Execute the given operation, optionally specifying a connection used to do so.
    /// If no connection is provided, server selection will performed using the criteria specified
    /// on the operation, if any.
    #[allow(dead_code)]
    pub(crate) fn execute_operation<T: Operation>(
        &self,
        op: &T,
        connection: Option<&mut Connection>,
    ) -> Result<T::O> {
        // if no connection provided, select one.
        match connection {
            Some(conn) => self.execute_operation_on_connection(op, conn)?,
            None => {
                let server = self.select_server(op.selection_criteria())?;
                let mut conn = server.checkout_connection()?;

                match self.execute_operation_on_connection(op, &mut conn) {
                    Ok(handled_result) => {
                        if let Err(ref e) = handled_result {
                            // If we encounter a "not master" or "node is recovering" error, we must
                            // update the topology as per the SDAM spec.
                            if e.is_recovering() || e.is_not_master() {
                                let description = ServerDescription::new(
                                    conn.address().clone(),
                                    Some(Err(e.clone())),
                                );
                                update_topology(self.topology(), description);
                                server.request_topology_check();

                                // in 4.2+, we only clear connection pool if we've received a
                                // "node is shutting down" error.
                                if conn
                                    .stream_description()
                                    .map(|sd| sd.max_wire_version.unwrap_or(0) >= 8)
                                    .unwrap_or(false)
                                {
                                    if e.is_shutting_down() {
                                        server.clear_connection_pool();
                                    }
                                } else {
                                    // otherwise, clear the pool for all "node is recovering or "not
                                    // master" errors.
                                    server.clear_connection_pool();
                                }
                            }
                        }
                        handled_result
                    }
                    Err(e) => {
                        // If we encounter a network error, we must update the topology as per the
                        // SDAM spec.
                        if e.is_network_error() {
                            let description = ServerDescription::new(
                                conn.address().clone(),
                                Some(Err(e.clone())),
                            );
                            update_topology(self.topology(), description);
                        }
                        Err(e)
                    }
                }
            }
        }
    }

    /// Executes an operation on a given connection.
    /// The first layer of errors correspond to any connection errors sending the command or
    /// receiving a response. The second layer correspond to those generated by
    /// `Operation::handle_response`.
    fn execute_operation_on_connection<T: Operation>(
        &self,
        op: &T,
        connection: &mut Connection,
    ) -> Result<Result<T::O>> {
        let cmd = op.build(connection.stream_description()?)?;
        let response = connection.send_command(cmd)?;
        Ok(op.handle_response(response))
    }
}
